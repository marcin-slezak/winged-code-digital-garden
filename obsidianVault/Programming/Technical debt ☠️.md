Technical debt is quick, easy, short term solutions made intentionally to get some desired value like a new functionality or fixed bug faster now at the expense of slower software development in the future.

Well, all of us makes hundreds of decisions daily basis, some of them are cheap, quick and easy but bad in long run like eating fast food, other ones require more effort or money but help us to avoid some issues in the future like well balanced and good quality meals. All our lives are a balance between fast and long term solutions. Technical debt reflects additional rework that needs to be done because in the past we choose easy and fast solutions and it can be related  to almost every aspect of software development like design, infrastructure, architecture, code quality or non-functional requirements. 

Technical debt is not necessarily a bad thing - many teams that work closely with businesses do that all the time. No without a reason technical debt sounds like financial debt. This analogy was created in 1992 to highlight that some shortcuts can help the technical team deliver desired functionalities faster in the short run but if the organisation will not repay technical debt, they will pay accumulated interest in the form of affected development velocity.

Quite interesting is the fact that a lot of people uses technical debt and mess terms interchangeably depends on if they want to highlight positive or negative meaning. Software developers raise the issue with technical debt when they don’t know how to handle rising complexity in the code but also management complains about the mess in technical teams trying to hide the fact that it was created intentionally by their decisions.


> A Mess is not a Technical Debt.
> *--Robert C Martin*

Technical debt is intentional, thoughtful decision to make a fast, solution where we understand and accept future implications in contrast to a mess that is unintentional, not planned, caused by missing skillset, knowledge or attention.

The bigger and more complex the application that we develop is, the more time takes to predict the implications of new features or changes. So, naturally, the bigger and more complex applications we build than software development is slower.

Technical debt and mess can easily spiral out of control and rise application development costs exponentially at the end blocking software development. The development of applications with naturally growing complexity will not slow down so dramatically. In the beginning, the differences are difficult to tell apart, later on, once software development is paralyzed is too late to take preventive actions.

So how do we know if we are facing early-stage technical debt, mess, or’s just naturally growing application complexity?


We can not measure technical debt or mess directly but having insights into the most common software quality metrics can give us a hint of what we are facing. Team velocity and defects statistics should be used as a warning light. The software development teams know the potential issues, they are the first ones who are facing difficulties with software development and good developers can recognize the reasons really precisely.  How differ technical debt from a mess? You just need to ask one question - who, when made a decision and what’s the repayment plan. 

In the end, often we are facing a mix of both: technical debt and mess. The main question is how much of that is intentionally and under control and how much is hidden and unpredictable. 

Examples of technical debt:

- The team can deliver new functionality faster without automated tests, testing new functionality only manually, so regression tests for future iterations will take more time.
- New integration between two systems could not be tested correctly ahead but because of business pressure, it had to go live. The team will have to handle additional support tickets to handle unhandled integration cases slowing down the development of other functionalities.
- The team can deliver new functionality faster without automated tests, testing new functionality only manually, so regression tests for future iterations will take more time.


